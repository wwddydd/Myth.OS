# 2.2 World Memory and Persistence

---

## 2.2.0 Memory as Substance

In Myth.OS, world memory is an active data structure that records, modifies, and resolves the state of the world across time.  
All persistent objects, regions, events, and entities are defined by their entries in the memory system.

World memory is stored in **structured YAML files**, automatically generated and updated by the Engine. These files evolve dynamically based on player interaction, environmental change, and symbolic events.

Memory entries may include:

- **Spatial data:** location coordinates, attachment hierarchies, bounding vectors  
- **Symbolic tags:** emotional fields, alignment history, ritual state  
- **Interaction logs:** recent changes, timestamps, and narrative flags

Schema are **flexible but scheme-directed**. The Engine uses predefined object schemes and modifies or extends them as needed. New memory entries are initialized from the most appropriate scheme based on interaction context, object type, or world-specific logic.

Memory is not limited to major structures. If configured accordingly, the system can track and store:

- Named pebbles, individual tree branches, fragments of broken items  
- Shifting water levels, weather cycles, ambient sounds  
- NPC moods, task states, and location trails

---

## 2.2.1 Accumulation, Drift, and Forgetting

When a player or agent interacts with a part of the world, the Engine records the event in that entity’s memory file.

Each interaction increases the **memory density** of the target, measured by frequency, emotional intensity, and narrative weight.  
As density increases, the Engine may:

- Refine the schema with new fields  
- Anchor symbolic states as persistent properties  
- Flag the object or area as “stabilized”

Memory decay occurs in the absence of interaction.

The Engine performs routine evaluations (e.g., during Midnight Cycle passes) to determine which elements should enter **drift**:

- Low-density memory regions may begin symbolic mutation  
- Structural data may be compressed, generalized, or removed  
- High-entropy zones may develop new traits, identities, or behavior patterns

This mechanism ensures that the memory footprint of the world remains scalable while enabling transformation over time.

---

## 2.2.2 Dynamic Reinforcement and Density Scaling

The Engine uses interaction data to adjust **granularity** of memory per region or object.

High-density memory zones receive:

- Full object schema with fine-grained fields  
- Long-term change logs  
- Cross-referenced entries in the world memory graph

Low-density or recently created zones may receive:

- Compressed schema  
- Procedural regeneration templates  
- Metadata-only summaries

This allows Myth.OS to support both minimal memory worlds and high-fidelity symbolic environments, depending on builder preference and player activity.

Builders can configure density thresholds in ETH.os to specify:

- Maximum object resolution  
- Criteria for compression  
- Rules for automatic archival or deletion

---

## 2.2.3 Fault Line Drift Mechanics

When symbolic or structural decay reaches a threshold, the Engine uses **fault line logic** to determine mutation pathways.

Fault lines are defined by:

- Surviving **symbolic tags** (e.g., betrayal, serenity, vigilance)  
- Spatial **memory vectors** (walls, road directions, elevation contours)  
- Stored **narrative flags** (e.g., region burned in war, site of great sorrow)

Drifted objects and regions will mutate along these vectors. For example:

- A ruined fortress associated with rage may become a volcanic crater  
- A decayed garden touched by grief may evolve into a dreamlike tomb  
- Structural features may persist symbolically: steps remembered as thresholds, doors as barriers

Fault line drift allows decayed memory to produce **meaningful transformations** without requiring full retention or design intervention.

---

## 2.2.4 Stable vs Decaying World Modes (ETH.os Parameters)

Each world defines its memory behavior through **ETH.os** — the world’s configuration file.

Key parameters include:

- `memory_mode: stable | decaying`  
- `prune_threshold: <float>` — decay triggers below this density  
- `preservation_zones: [region_id...]` — regions immune to decay  
- `max_schema_depth: <int>` — limits object complexity for scaling

**Stable Mode**:
- Memory is retained indefinitely unless manually deleted or force-pruned  
- Encourages detailed, persistent worlds with long-term historical layering  
- Suitable for simulationist or narrative-heavy settings

**Decaying Mode**:
- Unused or low-weight memory is compressed or discarded on schedule  
- Promotes symbolic transformation and dynamic regeneration  
- Supports dreamlike or mythic settings where change is expected

ETH.os may also define hybrid behaviors such as seasonal decay, entropy acceleration, or decay inversion (where frequent interaction causes instability).

---

## 2.2.5 Example Schema: `thing`

The Myth.OS Engine maintains world memory by instantiating object data from YAML-based schema. One core example is the **`thing`** schema, used to represent all interactable entities that are not strictly locations or creatures.

A `thing` can include:

- Physical items (e.g. tools, relics, debris)  
- Symbolic constructs (e.g. a curse, a fragmented memory)  
- Environmental details (e.g. furniture, signs, animated architecture)

### Key fields include:

- **`id`, `name`, and `description`** — human-readable and system-resolved identifiers  
- **`state_profile`** — properties such as `is_portable`, `is_container`, `is_alive`, or `is_bound`  
- **`symbolic_roles`** — defines narrative roles such as “key,” “threshold,” “anchor,” or “witness”  
- **`behavior` and `effects`** — trigger conditions and symbolic affordances  
- **`vexotra_overlays`** — conditional transformations based on emotional alignment vectors

Objects defined with this schema adapt based on player interaction and symbolic alignment.  
For example, if a player enters a sorrow-heavy state, an otherwise inert “stone bench” may gain a new description, emit a ghostly light, or unlock a hidden behavior path.

The `thing` schema illustrates several architectural principles of Myth.OS memory:

- **Schema-driven YAML** enables formalized, extensible object definitions  
- **Symbolic overlays** allow responsive changes without duplicating the base object  
- **Emotional state + memory context** shapes gameplay as much as mechanical state

Builders may subclass `thing` or define specialized symbolic tags relevant to their world logic.  
The Engine interprets extensions dynamically based on world configuration and player context.

> **[Link to `thing` schema: ./schema/thing.yaml]**  
> *(To be included in final schema index or reference appendix)*

---

## 2.2.6 Timestamping and Memory History

Myth.OS supports timestamping for both object interactions and memory state changes.  
This data is used for:

- Decay logic  
- Replay or inspection of narrative drift  
- Symbolic event tracking  
- Temporal anomaly detection or design

### Interaction Timestamps

By default, the Engine appends a `last_interacted` field to any object, region, or entity with persistent memory:

```yaml
last_interacted: 2087-04-17T13:55:02Z
```

Builders can configure:

- Timezone and format (UTC recommended for engine consistency)  
- Maximum retention duration  
- Whether timestamps affect pruning thresholds

---

### Version History and Symbolic Drift Logs

Objects may optionally store historical state changes using a versioned history log.  
This can be used for debugging, archival, or mythic storytelling.

```yaml
history:
  - time: 2083-03-21T00:00:00Z
    state:
      name: "Saria"
      role: "oracle"
      temperament: "kind"

  - time: 2086-11-10T00:00:00Z
    state:
      name: "Saria"
      role: "fallen oracle"
      temperament: "wrathful"
```

This history may be:

- Manually defined (by Builders)  
- Dynamically generated (by Engine policy)  
- Capped by count, age, or symbolic resolution (e.g., retain only events flagged as significant)

---

## 2.2.7 Memory Scope and Access Models

Myth.OS supports multiple memory scope configurations that define how world memory is accessed and shared among players.  
These scopes allow builders to control the visibility, divergence, and symbolic gating of persistent world data.

Memory scope is defined per object, location, region, or NPC. It can be explicitly declared in YAML or inferred by Engine rule.

---

### Scope Types

#### **Global**
All players share a single version of memory.  
When a change occurs (e.g. a town burns down), it is visible to all players immediately or at next world update.

```yaml
memory_scope: global
```

---

#### **Personal**
Each player (or party/faction) maintains a private copy of the object’s memory state.  
Changes are local until the Engine or a builder event reconciles or merges them.

Useful for:
- Dreams and hallucinations  
- Personal quests  
- Psychological distortions  
- Private hauntings

```yaml
memory_scope:
  type: personal
  key: player_id
```

---

#### **Conditional**
Memory exists in full, but visibility or access is gated by a symbolic or narrative condition.  
The object may appear differently depending on the viewer’s emotional state, alignment, class, or past actions.

```yaml
memory_scope:
  type: conditional
  condition: has_tag("reckoned_with_guilt")
```

---

### Use Cases

- A player sees a burned city only after visiting in person  
- A curse manifests only for characters aligned with fear  
- An NPC remembers a betrayal differently for each party involved  
- A god’s memory of a player diverges based on offerings or dreams

---

### Engine Considerations

- Personal and conditional scopes increase memory complexity  
- Builders should define reconciliation logic or use scheduled merges  
- Scoped memory should be used sparingly in high-traffic areas unless symbolic divergence is desired

---

Memory scope allows the world to maintain both canonical state and subjective experience — enabling fractured realities, layered truths, and player-specific world memory without breaking core coherence.